I started by sketching the schema: users keyed by header IDs, collections scoped to users with a uniqueness constraint on names, and collection_items with a unique constraint on `(collection_id, item_id)`. The 5-item cap needed a database-level guard, so I added a trigger that raises when inserts exceed the quota; the application also checks counts to return friendlier errors, but the trigger is the final safety net.

Hono routing was straightforward. Name collision handling was slightly tricky: I loop insert attempts with a unique constraint as the arbiter so concurrent requests cannot race past each other. The move operation needed careful locking and checks; wrapping it all in a transaction with `FOR UPDATE` on the touched rows keeps it atomic while still allowing the trigger to enforce capacity.

Sorting collections by value was easiest to keep in SQL using a `SUM` with a `CASE` for note weight and grouping to also return counts. Tests are integration-style against Postgres so they exercise the trigger and transactional moves; setting up the DB connection was the main friction point given the stack. Overall the constraints were reasonable—the DB-level limit is the most interesting part, and Drizzle’s raw SQL support made it manageable.
